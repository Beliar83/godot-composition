using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GodotCompositionSourceGenerator;

[Generator]
public class GodotCompositionSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<string> godotProjectDirProvider = context
            .SelectGlobalAnalyzerProperty(["GodotProjectDirBase64", "GodotProjectDir"]).Select((propertyData, _) =>
            {
                if (propertyData.value is null)
                {
                    throw new InvalidOperationException("Property 'GodotProjectDir' is null or empty.");
                }

                return propertyData.property == "GodotProjectDirBase64"
                    ? Encoding.UTF8.GetString(Convert.FromBase64String(propertyData.value))
                    : propertyData.value;
            });

        IncrementalValuesProvider<ClassDeclarationSyntax> componentProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetComponentClasses(ctx))
            .Where(t => t.isComponent)
            .Select((t, _) => t.Item1);

        context.RegisterSourceOutput(context.CompilationProvider
                .Combine(componentProvider.Collect())
                .Combine(godotProjectDirProvider),
            (ctx, t) => GenerateCode(ctx, t.Left.Left, t.Left.Right, t.Right));
    }

    private static (ClassDeclarationSyntax, bool isComponent) GetComponentClasses(
        GeneratorSyntaxContext context)
    {
        ClassDeclarationSyntax classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        if (classDeclarationSyntax.BaseList?.Types.Select(t => t.Type).OfType<IdentifierNameSyntax>()
                .Select(i => context.SemanticModel.GetSymbolInfo(i).Symbol).OfType<ITypeSymbol>().All(s =>
                    !s.InheritsFrom(context.SemanticModel.Compilation.AssemblyName ?? "GodotComposition",
                        "GDExtension.Wrappers.Component")) ?? true)
        {
            return (classDeclarationSyntax, false);
        }

        return (classDeclarationSyntax, true);
    }

    private static string RelativeToDir(string path, string dir)
    {
        // Make sure the directory ends with a path separator
        dir = Path.Combine(dir, " ").TrimEnd();

        if (Path.DirectorySeparatorChar == '\\')
        {
            dir = dir.Replace("/", "\\") + "\\";
        }

        Uri fullPath = new(Path.GetFullPath(path), UriKind.Absolute);
        Uri relRoot = new(Path.GetFullPath(dir), UriKind.Absolute);

        // MakeRelativeUri converts spaces to %20, hence why we need UnescapeDataString
        return Uri.UnescapeDataString(relRoot.MakeRelativeUri(fullPath).ToString());
    }

    private static void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> componentDeclarations, string godotProjectDir)
    {
        StringBuilder registerComponentsBuilder = new();
        registerComponentsBuilder.AppendLine("// <auto-generated/>");
        registerComponentsBuilder.AppendLine("#nullable enable");
        registerComponentsBuilder.AppendLine("using Godot;");
        registerComponentsBuilder.AppendLine("using Godot.Collections;");
        registerComponentsBuilder.AppendLine("using GDExtension.Wrappers;");
        registerComponentsBuilder.AppendLine("");
        registerComponentsBuilder.AppendLine("namespace GodotComposition;");
        registerComponentsBuilder.AppendLine("");
        registerComponentsBuilder.AppendLine("public partial class GodotComposition");
        registerComponentsBuilder.AppendLine("{");
        registerComponentsBuilder.AppendLine(
            "\tstatic partial void RegisterComponentScripts(GodotCompositionEditorPlugin plugin)");
        registerComponentsBuilder.AppendLine("\t{");

        foreach (ClassDeclarationSyntax classDeclarationSyntax in componentDeclarations)
        {
            SemanticModel semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            Location location = classDeclarationSyntax.GetLocation();
            if (!location.IsInSource)
            {
                continue;
            }

            if (location.SourceTree?.FilePath is null)
            {
                continue;
            }

            string scriptPath = RelativeToDir(location.SourceTree.FilePath, godotProjectDir);

            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            registerComponentsBuilder.AppendLine($"\t\tplugin.RegisterComponentScript(\"res://{scriptPath}\");");
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            string className = classDeclarationSyntax.Identifier.Text;
            StringBuilder componentConstructorGenerator = new();
            componentConstructorGenerator.AppendLine("// <auto-generated/>");
            componentConstructorGenerator.AppendLine("using Godot;");
            componentConstructorGenerator.AppendLine("using GDExtension.Wrappers;");
            componentConstructorGenerator.AppendLine("using System;");
            componentConstructorGenerator.AppendLine();
            componentConstructorGenerator.AppendLine($"namespace {namespaceName};");
            componentConstructorGenerator.AppendLine();
            componentConstructorGenerator.AppendLine($"partial class {className}");
            componentConstructorGenerator.AppendLine("{");
            componentConstructorGenerator.AppendLine(
                "\t[Obsolete(\"Wrapper classes cannot be constructed with Ctor (it only instantiate the underlying RefCounted), please use the Instantiate() method instead.\")]");
            componentConstructorGenerator.AppendLine($"\tprotected {className}() {{ }}");
            componentConstructorGenerator.AppendLine("\t/// <summary>");
            componentConstructorGenerator.AppendLine(
                "\t/// Creates an instance of the GDExtension <see cref=\"Component\"/> type, and attaches the wrapper script to it.");
            componentConstructorGenerator.AppendLine("\t/// </summary>");
            componentConstructorGenerator.AppendLine(
                "\t/// <returns>The wrapper instance linked to the underlying GDExtension type.</returns>");
            componentConstructorGenerator.AppendLine("\tpublic new static Component Instantiate()");
            componentConstructorGenerator.AppendLine("\t{");
            componentConstructorGenerator.AppendLine(
                $"\t\treturn GDExtensionHelper.Instantiate<{className}>(GDExtensionName);");
            componentConstructorGenerator.AppendLine("\t}");

            componentConstructorGenerator.AppendLine("}");
            context.AddSource($"{className}.g.cs",
                SourceText.From(componentConstructorGenerator.ToString().Replace("\t", "    "), Encoding.UTF8));
        }

        registerComponentsBuilder.AppendLine("\t}");
        registerComponentsBuilder.AppendLine("}");
        context.AddSource("GodotComposition.g.cs",
            SourceText.From(registerComponentsBuilder.ToString().Replace("\t", "    "), Encoding.UTF8));
    }
}